/*
 *                Genetics Algorithm to Grow Your Own Picture
 *
 * Copyright (c) 2013 Chris Cummins
 * http://chriscummins.cc
 * http://chriscummins.cc/genetics.html
 *
 * Based on the fantastic `JavaScript Genetic Algorithm' by Jacob Seidelin,
 * available at:
 *
 *   http://www.nihilogic.dk/labs/evolving-images/
 *
 * This file is documented with JSDoc comments. If you have a checkout of this
 * webpage repository, use `make docs' to generate docuemntation under
 * Documentation/genetics/.
 *
 * Seidelin's JavaScript Genetic Algorithm header:
 *
 *   Copyright (c) 2009 Jacob Seidelin
 *   jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
 *   MIT License [http://www.nihilogic.dk/licenses/mit-license.txt]
 */

/**
 * @file
 *
 * Genetics Algorithms to Grow Your Own Picture.
 */

'use strict';


/**
 * We keep a reference to the document body for convenient typing.
 */
var body = document.body;


/**
 * The analytics pane elements
 */
var ap;


/**
 * The working canvas, used by the fitness function to determine an individuals
 * fitness.
 */
var workingCanvas;


/**
 * The 2D drawing context of the working canvas, as returned by the getContext()
 * method.
 */
var workingCtx;

var workingData = [];


/**
 * The output workspace, where we display the fittest population.
 */
var outputCanvas;


/**
 * The 2D drawing context of the output canvas, as returned by the getContext()
 * method.
 */
var outputCtx;


/**
 * The reference canvas, where we display the target image that we are selecting
 * towards.
 */
var referenceCanvas;


/**
 * The 2D drawing context of the reference canvas, as returned by the
 * getContext() method.
 */
var referenceCtx;


/**
 * The reference image.
 */
var referenceImage;

/*
 * Simulation session variables.
 */

/* User set configuration */
var diffSquared;
var fillPolygons;
var killParents;
var mutateAmount;
var mutationChance;
var selectionCutoff;
var polygons;
var populationSize;
var uniformCrossover;
var vertices;
var workingSize;

/* Simulation session variables */
var clock;
var dnaCrossLength;
var dnaLength;
var geneSize;
var highestFitness;
var jiffies;
var lowestFitness;
var population;
var startTime;

/*
 * Pseudo-random number set.
 *
 * We generate a pool of pseudo-random float values which can be accessed using
 * getRand(). This is a performance optimisation to reduce the number of calls
 * to Math.random() made by the heavily randomised algorithms used in the
 * genetics modelling.
 */
for (var i = 1e6, randPool = []; i--;) {
  randPool.push(Math.random());
}


/**
 * Fetches a random float in the range [0, 1], selected from a pool of 1 million
 * values, generated at page load.
 *
 * @return {float} Pseudo-random number in the range [0, 1].
 */
function getRand() {
  return ++i >= randPool.length ? randPool[i = 0] : randPool[i];
}

/*
 * Utility functions.
 */


/**
 * Determines whether the genetics program is compatible with the host
 * browser. Returns true if yes, else false.
 *
 * @return {boolean} True if supported, else false.
 */
function geneticsIsSupported() {
  var isSupported = false;

  /* perform a simple check to verify that getContext() and getImageData() are
   * supported */
  if (referenceCanvas.getContext &&
      referenceCanvas.getContext('2d').getImageData) {
    isSupported = true;
  }

  return isSupported;
}


/**
 * Convert a seconds value to a human-redable string.
 *
 * @param {int} s The number of seconds.
 * @return {string} A time value in the form [hh:m]m:ss.
 */
function secondsToString(s) {
  var h = Math.floor(s / 3600);
  var m = Math.floor(s % 3600 / 60);

  s = Math.floor(s % 3600 % 60);

  return ((h > 0 ? h + ':' : '') +
          (m > 0 ? (h > 0 && m < 10 ? '0' : '') +
           m + ':' : '0:') + (s < 10 ? '0' : '') + s);
}


/**
 * Draw a representation of a DNA string to a canvas.
 *
 * @param {Canvas} ctx The 2D drawing context.
 * @param {int} width The canvas width (pixels).
 * @param {int} height The canvas height (pixels).
 * @param {float[]} dna The DNA string.
 */
function drawDNA(ctx, width, height, dna) {

  /* draw the gene at index `g' */
  function drawGene(g) {
    /* starting vertex */
    ctx.beginPath();
    ctx.moveTo((dna[g + 4]) * width, (dna[g + 5]) * height);

    /* create each vertex */
    for (var i = 0; i < vertices - 1; i++) {
      ctx.lineTo((dna[g + i * 2 + 6]) * width, (dna[g + i * 2 + 7]) * height);
    }

    ctx.closePath();

    var styleString = 'rgba(' +
        ((dna[g] * 255) >> 0) + ',' + // R - int [0,255]
        ((dna[g + 1] * 255) >> 0) + ',' + // G - int [0,255]
        ((dna[g + 2] * 255) >> 0) + ',' + // B - int [0,255]
        dna[g + 3] + ')'; // A - float [0,1]

    if (fillPolygons) {
      /* create a polygon */
      ctx.fillStyle = styleString;
      ctx.fill();
    } else {
      /* trace an outline */
      ctx.lineWidth = 1;
      ctx.strokeStyle = styleString;
      ctx.stroke();
    }
  }

  /* set the background */
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, width, height);

  /* draw each gene sequentially */
  for (var g = 0; g < dnaLength; g += geneSize)
    drawGene(g);
}



/**
 * Creates a new individual. Each individual comprises of their string of DNA,
 * and the fitness. Both of these are generated in the constructor, there is no
 * other behaviour. If mother father are omitted, this generates a random
 * individual.
 *
 * @param {Individual} mother The mother.
 * @param {Individual} father The father.
 * @property {float[]} dna The individuals DNA.
 * @property {float} fitness The individuals fitness [0, 1].
 * @constructor
 */
function Individual(mother, father) {


  this.dna = [];

  /* get the DNA */
  if (mother && father) {
    /* breed the individual from parents */
    var cross = (getRand() * dnaLength) >> 0;

    for (var i = 0; i < dnaLength; i += dnaCrossLength) {
      var val;
      var par;

      if (uniformCrossover) {

        if (getRand() < 0.5)
          par = mother;
        else
          par = father;

      } else {

        if (i < cross)
          par = mother;
        else
          par = father;
      }

      for (var j = 0; j < dnaCrossLength; j++) {
        val = par[i + j];

        if (getRand() < mutationChance) {
          val += getRand() * mutateAmount * 2 - mutateAmount;

          if (val < 0) val = 0;
          if (val > 1) val = 1;
        }
        this.dna.push(val);
      }
    }
  } else {
    /* generate a random individual */
    for (var g = 0; g < dnaLength; g += geneSize) {
      /* generate RGBA color values */
      this.dna.push(getRand(), // R
                    getRand(), // G
                    getRand(), // B
                    Math.max(getRand() * getRand(), 0.2)); // A

      /* generate XY positional values */
      var x = getRand();
      var y = getRand();

      for (var j = 0; j < vertices; j++) {
        this.dna.push(x + getRand() - 0.5, // X
                      y + getRand() - 0.5); // Y
      }
    }
  }

  /* determine the fitness */
  drawDNA(workingCtx, workingSize, workingSize, this.dna);
  var imageData = workingCtx.getImageData(0, 0,
                                          workingSize,
                                          workingSize).data;
  var dif = 0;
  var p = workingSize * workingSize * 4 - 1;

  do {
    if (p % 3) {
      var dp = imageData[p] - workingData[p];
      if (diffSquared) {
        dif += dp * dp;
      } else {
        if (dp < 0)
          dif -= dp;
        else
          dif += dp;
      }
    }
  } while (--p);

  if (diffSquared) {
    this.fitness = (1 - dif / (workingSize * workingSize * 3 * 256 * 256));
  } else {
    this.fitness = (1 - dif / (workingSize * workingSize * 3 * 256));
  }
}



/**
 * Representation of a full population
 * @param {int} size The number of individuals in the population.
 * @constructor
 */
function Population(size) {
  var individuals = [];

  for (var i = 0; i < size; i++) {
    individuals.push(new Individual());
  }

  /* breed a new generation */
  this.nextGeneration = function(mutationChance, mutateAmount) {

    if (individuals.length > 1) {
      var offspring = [];

      /* the number of individuals from the current generation to select for
       * breeding */
      var selectCount = Math.floor(individuals.length * selectionCutoff);

      /* the number of individuals to randomly generate */
      var randCount = Math.ceil(1 / selectionCutoff);

      individuals = individuals.sort(function(a, b) {
        return b.fitness - a.fitness;
      });

      if (!killParents)
        randCount--;

      for (var i = 0; i < selectCount; i++) {
        var dna = individuals[i].dna;

        for (var j = 0; j < randCount; j++) {
          var randIndividual = i;

          while (randIndividual == i)
            randIndividual = (getRand() * selectCount) >> 0;

          offspring.push(new Individual(dna, individuals[randIndividual].dna));
        }
      }

      if (killParents) {
        individuals = offspring;
      } else {
        individuals.length = selectCount;
        individuals = individuals.concat(offspring);
      }

      individuals.length = size;
    } else {
      /* asexual reproduction */
      var parent = individuals[0];
      var child = new Individual(parent.dna, parent.dna);

      if (child.fitness > parent.fitness) {
        individuals = [child];
      }
    }
  };

  this.getSize = function() {
    return individuals.length;
  };

  this.getFittest = function() {
    return individuals.sort(function(a, b) {
      return b.fitness - a.fitness;
    })[0];
  };
}

/*
 * Simulation functions
 */


/**
 * Determines whether the genetics simulation is currently running.
 *
 * @return {boolean} True if running, else false.
 */
function isRunning() {
  return clock;
}


/**
 * Determines whether the genetics simulation is currently paused.
 * @return {boolean} True if paused, else false.
 */
function isPaused() {
  return jiffies && !clock;
}


/**
 * Determines whether the genetics simulation is currently stopped.
 * @return {boolean} True if stopped, else false.
 */
function isStopped() {
  return !isRunning() && !isPaused();
}


/**
 * Upload a new file to use as a reference image.
 *
 * @param {File} e The target file.
 */
function fileSelectCb(e) {
  var file = e.target.files[0];

  document.getElementById('null').innerHTML = '<embed src="/shutter.mp3" ' +
      'hidden="true" autostart="true" loop="false" />';

  /* FIXME: AJAX */
  $('#image-upload-form').submit();

  console.log(file.name);
}


/**
 * Set a new image to use as the reference image.
 *
 * @param {string} src The path to the new image.
 */
function setImage(src) {
  referenceImage.onload = prepareImage;
  referenceImage.src = src;
}


/**
 * Prepare an image for use as the reference image.
 */
function prepareImage() {
  /* FIXME: add support for images of size other than 350x350. This requires
   * scaling the image and cropping as needed */

  referenceCanvas.width = workingSize;
  referenceCanvas.height = workingSize;

  referenceCtx.drawImage(referenceImage,
                         0, 0, 350, 350, 0, 0,
                         workingSize, workingSize);

  var imageData = referenceCtx.getImageData(0, 0,
                                            workingSize,
                                            workingSize).data;

  workingData = [];
  var p = workingSize * workingSize * 4;

  for (var i = 0; i < p; i++) {
    workingData[i] = imageData[i];
  }

  referenceCanvas.width = 350;
  referenceCanvas.height = 350;
  referenceCtx.drawImage(referenceImage, 0, 0);
  highestFitness = 0;
  lowestFitness = 100;
}


/**
 * Retrieve the session from the configuration panel
 */
function getConfiguration() {
  diffSquared = $('#diff-squared')[0].checked;
  fillPolygons = $('#fill-polygons')[0].checked;
  killParents = $('#killparents')[0].checked;
  mutateAmount =
      parseFloat($('#mutation-amount option:selected').text()) / 100;
  mutationChance =
      parseFloat($('#mutation-chance option:selected').text()) / 100;
  selectionCutoff =
      parseFloat($('#selection-cutoff option:selected').text()) / 100;
  workingSize = parseInt($('#internal-resolution option:selected').text());
  polygons = parseInt($('#polygons option:selected').text());
  populationSize = parseInt($('#population-size option:selected').text());
  uniformCrossover = $('#uniformcross').checked;
  vertices = parseInt($('#vertices option:selected').text());

  /* derive certain state variables */
  dnaCrossLength = (4 + vertices * 2);
  dnaLength = polygons * (4 + vertices * 2);
  geneSize = 4 + vertices * 2;

  /* set the working canvas dimensions */
  workingCanvas.width = workingSize;
  workingCanvas.height = workingSize;
  workingCanvas.style.width = workingSize;
  workingCanvas.style.height = workingSize;
}


/**
 * Run the simulation.
 */
function runSimulation() {
  body.classList.remove('genetics-inactive');
  body.classList.add('genetics-active');

  if (isStopped()) {
    jiffies = 0;
    startTime = new Date().getTime();
    population = new Population(populationSize);
  }

  /* Each tick produces a new population and new fittest */
  function tick() {
    /* breed a new generation */
    population.nextGeneration();
    jiffies++;

    var fittest = population.getFittest();
    var totalTime = ((new Date().getTime() - startTime) / 1000);
    var timePerGeneration = (totalTime / jiffies) * 100;
    var timePerImprovment = 0;
    var currentFitness = (fittest.fitness * 100);

    lowestFitness = (currentFitness < lowestFitness) ?
        currentFitness : lowestFitness;
    highestFitness = (currentFitness > highestFitness) ?
        currentFitness : highestFitness;

    /* draw the best fit to output */
    drawDNA(outputCtx, 350, 350, fittest.dna);

    /* write out the internal state to analytics panel */
    ap.elapsedTime.text(secondsToString(Math.round(totalTime)));
    ap.numberOfGenerations.text(jiffies);
    ap.timePerGeneration.text(timePerGeneration.toFixed(2) + ' ms');
    ap.timePerImprovment.text(timePerImprovment.toFixed(2) + ' ms');
    ap.currentFitness.text(currentFitness.toFixed(2) + '%');
    ap.highestFitness.text(highestFitness.toFixed(2) + '%');
    ap.lowestFitness.text(lowestFitness.toFixed(2) + '%');
  }

  /* Begin the master clock */
  clock = setInterval(tick, 0);
}


/**
 * Start the simulation.
 */
function startSimulation() {
  if (isStopped()) {
    getConfiguration();
    prepareImage();
  }

  $('select').attr('disabled', true);
  $('.ios-switch').attr('disabled', true);
  $('#start').text('Pause');
  $('#strongest-dna').text('');
  runSimulation();
}


/**
 * Pause the simulation.
 */
function pauseSimulation() {
  clearInterval(clock);
  clock = null;
  $('#start').text('Resume');
  $('#strongest-dna').text(population.getFittest().dna);
}


/**
 * End the simulation.
 */
function stopSimulation() {
  clearInterval(clock);
  clock = null;
  jiffies = null;
  startTime = null;
  population = null;
  highestFitness = 0;
  lowestFitness = 100;
  $('#elapsed-time').text('0:00');
  $('select').attr('disabled', false);
  $('.ios-switch').attr('disabled', false);
  $('#strongest-dna').text('');

  body.classList.remove('genetics-active');
  body.classList.add('genetics-inactive');

  /* Clear the drawing */
  outputCtx.clearRect(0, 0, 350, 350);
  workingCtx.clearRect(0, 0, workingSize, workingSize);

  $('#start').text('Start');
}

/*
 * Page interaction.
 */

/* stock image dropdown item selected */
$('#stock-image-menu li a').click(function() {
  setImage('/genetics/' +
           $(this).text().toLowerCase().replace(/ /g, '-') +
           '.jpg');
});

/* start button callback */
$('#start').click(function() {
  if (isRunning()) {
    pauseSimulation();
  } else {
    startSimulation();
  }
});

/* stop button callback */
$('#stop').click(function() {
  if (isRunning() || isPaused()) {
    stopSimulation();
  }
});

/* webcam button callback */
$('#webcam-upload-btn').click(function() {
  $('.underlay').fadeIn('slow');
  $('.webcam-overlay').fadeIn('fast');
});


/**
 * Dispose of the webcam upload overlay.
 */
function hideWebcamUpload() {
  $('.underlay').fadeOut('slow');
  $('.webcam-overlay').fadeOut('fast');
}


/**
 * Webcam image upload complete.
 *
 * @param {string} url The fully qualified URL to the uploaded webcam image.
 */
function webcamUploadComplete(url) {
  if (url.match(/^http:\/\//)) {
    setImage(url);
    webcam.reset();
    hideWebcamUpload();
  }
  else {
    alert('PHP Error: ' + url);
  }
}

/* underlay grabs all input and hides */
$('.underlay').click(function() {
  hideWebcamUpload();
});


/**
 * Take a webcam snapshot.
 */
function webcamTakeSnapshot() {
  webcam.snap();
}


/**
 * document ready preparations
 */
window.onload = function() {

  /* set our page element variables */
  outputCanvas = $('#outputCanvas')[0];
  outputCtx = outputCanvas.getContext('2d');

  workingCanvas = $('#workingCanvas')[0];
  workingCtx = workingCanvas.getContext('2d');

  referenceImage = $('#referenceImage')[0];
  referenceCanvas = $('#referenceCanvas')[0];
  referenceCtx = referenceCanvas.getContext('2d');

  /* analytics panel */
  ap = {
    elapsedTime: $('#elapsed-time'),
    numberOfGenerations: $('#number-of-generations'),
    timePerGeneration: $('#time-per-generation'),
    timePerImprovment: $('#time-per-improvement'),
    currentFitness: $('#current-fitness'),
    highestFitness: $('#highest-fitness'),
    lowestFitness: $('#lowest-fitness')
  };

  /* check that we can run the program */
  if (!geneticsIsSupported())
    alert('Unable to run genetics program!'); /* FIXME: better alert */

  /* prepare the reference image default */
  getConfiguration();
  prepareImage();

  /* prepare the ios switches */
  var iosSwitches =
      document.querySelectorAll('input[type="checkbox"].ios-switch');
  for (var i = 0, sw; sw = iosSwitches[i++];) {
    var div = document.createElement('div');
    div.className = 'switch';
    sw.parentNode.insertBefore(div, sw.nextSibling);
    sw.style.width = div.style.width;
    sw.style.height = div.style.height;
  }

  /* FIXME: not yet implemented */
  /* attach the file chooser callback */
  /* $('#file-chooser')[0].addEventListener('change', fileSelectCb, false); */

  /* setup webcam upload */
  webcam.set_api_url('webcam.php');
  webcam.set_quality(90);
  webcam.set_shutter_sound(true);
  webcam.set_hook('onComplete', 'webcamUploadComplete');
  $('#webcam-preview')[0].innerHTML = webcam.get_html(350, 350);
};
